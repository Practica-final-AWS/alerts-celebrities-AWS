AWSTemplateFormatVersion: '2010-09-09'
Description: S3 to SQS to Lambda with Rekognition, DynamoDB and SNS.

Resources:
  # 1. DynamoDB Table
  CelebrityResultsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: CelebrityDetectionResults
      AttributeDefinitions:
        - AttributeName: ImageKey
          AttributeType: S
      KeySchema:
        - AttributeName: ImageKey
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  # 2. SQS Queue
  ImageProcessQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: image-processing-queue

  # 3. SQS Policy (Allows S3 to send messages)
  QueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref ImageProcessQueue
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action: sqs:SendMessage
            Resource: !GetAtt ImageProcessQueue.Arn
            Condition:
              ArnLike:
                # We hardcode the ARN structure to break the dependency loop
                aws:SourceArn: !Sub "arn:aws:s3:::celebrity-upload-bucket-${AWS::AccountId}"
  # 4. S3 Bucket
  ImageBucket:
    Type: AWS::S3::Bucket
    DependsOn: QueuePolicy
    Properties:
      BucketName: !Sub "celebrity-upload-bucket-${AWS::AccountId}"
      CorsConfiguration:
        CorsRules:
          - AllowedOrigins:
              - "*"
            AllowedMethods:
              - PUT
              - POST
              - GET
            AllowedHeaders:
              - "*"
            ExposedHeaders:
              - ETag
            MaxAge: 3000
      NotificationConfiguration:
        QueueConfigurations:
          - Event: s3:ObjectCreated:*
            Queue: !GetAtt ImageProcessQueue.Arn

  # 5. Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - s3:GetObject
                  - rekognition:RecognizeCelebrities
                  - dynamodb:PutItem
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sns:Publish

                Resource: "*"

  # 6. Lambda Function
  CelebrityLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CelebrityRecognitionHandler
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      Environment:
        Variables:
          TABLE_NAME: !Ref CelebrityResultsTable
          SNS_TOPIC_ARN: !Ref CelebrityAlertTopic
      Code:
        ZipFile: |
          import boto3
          import os
          import json

          rekognition = boto3.client('rekognition')
          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])
          sns = boto3.client('sns')
          sns_topic_arn = os.environ['SNS_TOPIC_ARN']

          def handler(event, context):
              for record in event['Records']:
                  # SQS body contains the S3 event
                  s3_event = json.loads(record['body'])
                  if 'Records' not in s3_event: continue
                  
                  for s3_rec in s3_event['Records']:
                      bucket = s3_rec['s3']['bucket']['name']
                      key = s3_rec['s3']['object']['key']
                      
                      # Call Rekognition
                      response = rekognition.recognize_celebrities(
                          Image={'S3Object': {'Bucket': bucket, 'Name': key}}
                      )
                      
                      celebs = response.get('CelebrityFaces', [])
                      is_celebrity = len(celebs) > 0
                      # celeb_name = str(celebs[0]['Name']) if is_celebrity else "None"
                      if is_celebrity:
                          celeb_name = str(celebs[0].get('Name', 'Unknown'))
                          match_confidence = float(celebs[0].get('MatchConfidence', 0.0))
                      else:
                          celeb_name = "None"
                          match_confidence = 0.0

                      # Save to DynamoDB
                      table.put_item(Item={
                          'ImageKey': key,
                          'IsCelebrity': is_celebrity,
                          'CelebrityName': celeb_name,
                          'MatchConfidence': match_confidence,
                          'Bucket': bucket
                      })

                      # Publicar en SNS si hay un famoso
                      if is_celebrity:
                          message = f"Se detectó al famoso {celeb_name} en la imagen {key} del bucket {bucket}."
                          sns.publish(
                              TopicArn=sns_topic_arn,
                              Message=message,
                              Subject="Alerta de Celebridad Detectada"
                          )
              return {"status": "success"}

  # 7. SQS-to-Lambda Trigger
  LambdaEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 10
      EventSourceArn: !GetAtt ImageProcessQueue.Arn
      FunctionName: !Ref CelebrityLambda

  
  # 8. SNS-alerts
  CelebrityAlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: CelebrityAlertTopic

  CelebrityAlertSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      Endpoint: 22577867@live.uem.es  # Reemplaza con tu correo
      TopicArn: !Ref CelebrityAlertTopic


#Cambios añadidos para incorporar página web html
# ----------------------------
# S3 - WEB
# ----------------------------
  WebBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "web-bucket-html-${AWS::AccountId}"
      WebsiteConfiguration:
        IndexDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  WebBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref WebBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub ${WebBucket.Arn}/*
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${WebDistribution}

# ----------------------------
# CLOUDFRONT
# ----------------------------

  ## Origin Access Control
  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "${AWS::StackName}-oac"
        Description: Access control for CloudFront to S3
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  WebDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        Origins:
          - Id: WebOrigin
            DomainName: !GetAtt WebBucket.RegionalDomainName
            OriginAccessControlId: !Ref CloudFrontOAC
            S3OriginConfig: {}
        DefaultCacheBehavior:
          TargetOriginId: WebOrigin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD]
          CachedMethods: [GET, HEAD]
          DefaultTTL: 0          # Tiempo en cache por defecto = 0 segundos
          MaxTTL: 0              # TTL máximo = 0
          MinTTL: 0              # TTL mínimo = 0
          ForwardedValues:
            QueryString: true      # Para que respete query strings (útil si haces ?v=1)
            Headers:
              - Origin            # Para que respete headers de control
            Cookies:
              Forward: none
        ViewerCertificate:
          CloudFrontDefaultCertificate: true

  # Lambda para generar URL prefirmada
  LambdaUploadRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: upload_policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: s3:PutObject
                Resource: !Sub "arn:aws:s3:::celebrity-upload-bucket-${AWS::AccountId}/*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  # ----------------------------
  # LAMBDA (PYTHON)
  # ----------------------------
  UploadLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: generate-upload-url
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaUploadRole.Arn
      Timeout: 10
      Environment:
        Variables:
          BUCKET_NAME: !Sub "celebrity-upload-bucket-${AWS::AccountId}"
      Code:
        ZipFile: |
          import json, boto3, os, time
          s3 = boto3.client("s3")
          BUCKET = os.environ["BUCKET_NAME"]
          ALLOWED = ["image/png","image/jpeg","image/jpg","image/gif","image/webp"]

          def lambda_handler(event, context):
              # body = json.loads(event.get("body","{}"))
              raw_body = event.get("body") or "{}"
              body = json.loads(raw_body) if isinstance(raw_body, str) else raw_body
              if body.get("contentType") not in ALLOWED:
                  return resp(400,"Invalid type")
              key = f"uploads/{int(time.time())}-{body['filename']}"
              url = s3.generate_presigned_url(
                  "put_object",
                  Params={"Bucket":BUCKET,"Key":key,"ContentType":body["contentType"]},
                  ExpiresIn=60
              )
              return {"statusCode":200,"headers":{"Access-Control-Allow-Origin":"*"},"body":json.dumps({"uploadUrl":url})}

          def resp(c,m):
              return {"statusCode":c,"headers":{"Access-Control-Allow-Origin":"*"},"body":json.dumps({"error":m})}
# ----------------------------
# API GATEWAY
# ----------------------------
  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: upload-api
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins: ["*"]
        AllowMethods: ["POST","OPTIONS"]
        AllowHeaders: ["*"]

  UploadIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt UploadLambda.Arn
      IntegrationMethod: POST
      PayloadFormatVersion: "2.0"

  UploadRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: "POST /upload-url"
      Target: !Sub integrations/${UploadIntegration}

  UploadStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref HttpApi
      StageName: "$default"
      AutoDeploy: true

  UploadPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref UploadLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*/POST/upload-url
